<!DOCTYPE html>

<html lang="en">

<head>
    <title></title>
    <script type="text/javascript" src="lib/three.js"></script>
    <script type="text/javascript" src="lib/dat.gui.js"></script>
    <script type="text/javascript" src="lib/TrackballControls.js"></script>
    <script type="text/javascript" src="lib/uclass_TeapotGeometry.js"></script>

    <style>
        body {
            margin: 0;
            overflow: hidden;
        }
    </style>
</head>
<body>

<div id="container"></div>
</body>

<script type="x-shader/x-vertex" id="teapotVertexShader">
	precision mediump float;

	varying vec3 vPosition;
	varying vec3 vPosInCamera;
	varying vec3 vNormal;
	varying vec2 vUv;
	uniform float uDirX, uDirY, uDirZ, uShininess;

	void main(void) {
		vUv = uv;
		vNormal = normalMatrix * normal;
		vPosition = position;
	    vPosInCamera = (viewMatrix * modelMatrix * vec4(position, 1.0 )).xyz;
    	gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0 );
	}

</script>

<script type="x-shader/x-vertex" id="teapotFragmentShader">
	precision mediump float;

	uniform float uScale;
	uniform float uEdge;

	varying vec3 vPosition;
	varying vec3 vPosInCamera;
	varying vec3 vNormal;
	varying vec2 vUv;
	uniform float uDirX, uDirY, uDirZ, uShininess;
    #extension GL_OES_standard_derivatives : enable

    vec3 smoothColor(float f, float uEdge, vec3 firstColor, vec3 secondColor) {
        float grad = length(vec2(dFdx(f),dFdy(f)));
        float d = uEdge*grad;
        float edgeFactor = smoothstep(-d, d, f);
        return mix(firstColor, secondColor, edgeFactor);
   }

    float circle(float u, float v) {
        return u*u + v*v - 0.25*0.25;
    }

	void main() {
		vec3 ambColor = vec3(0.1,0.1,0.1);
        vec3 diffColor = vec3(0.6,0.6,0.6);
        vec3 specColor = vec3(0.4,0.4,0.3);
        vec4 spec = vec4(0.0);

		vec3 lightDir = normalize(vec3(uDirX,uDirY,uDirZ));
		float diffLightWeight = max(dot(lightDir, normalize(vNormal)), 0.0);
        vec3 eyeDir = normalize(-vPosInCamera);
        vec3 reflDir = -reflect(lightDir, vNormal);
        float specLightWeight = pow(max(dot(reflDir, eyeDir), 0.0), uShininess);
		vec3 lightWeight = ambColor + diffColor * diffLightWeight
			+ specColor * specLightWeight;
	    vec3 color = vec3(lightWeight);

    vec3 blue = vec3(0.0,0.0,0.9);
    vec3 yellow = vec3(1,1,0);
    vec3 magenta = vec3(1,0,1);
    vec3 cyan = vec3(0,1,1);

    float u = fract(vUv.x * uScale);
    float v = fract(vUv.y * uScale);
    float f = u*(u-0.5)*(u-1.0)*v*(v-0.5)*(v-1.0);
    vec3 finalColor = smoothColor(f, uEdge, magenta,blue);

    float downFunction = v + u - 1.0;
    float upFunction = -u + v;
    // right bottom blue outter circle
    if (v>0.5 && u>0.5) {
        finalColor = smoothColor(upFunction, uEdge, magenta, finalColor);
    } else if (v<0.5 && u <0.5) {
        finalColor = smoothColor(-upFunction, uEdge, magenta, finalColor);
    }
    else if (v>0.5 && u<0.5) {
        finalColor = smoothColor(downFunction, uEdge, blue, finalColor);
    }
     else {
        finalColor = smoothColor(-downFunction, uEdge, blue, finalColor);
    }

   //middle circle
    u = fract(vUv.x * uScale)-0.5;
    v = fract(vUv.y * uScale)-0.5;
    if (u>0.0 && v>u) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else if ((v<0.0 && u>0.0 && u>-v)) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else if ((v<0.0 && u<0.0 && v<u)) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else if ((u<0.0 && v>0.0 && -u>v)) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else {
        finalColor = smoothColor(circle(u, v), uEdge, yellow, finalColor);
    }

    // bottom left circle
    u = fract(vUv.x * uScale)-0.25;
    v = fract(vUv.y * uScale)-0.25;

    float centerCircle = circle(u-0.25, v-0.25);
    if (v<u) {
        if (centerCircle < 0.0) {
            finalColor = smoothColor(circle(u, v), uEdge, blue, finalColor);
        } else {
            finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
        }
    } else {
        if (centerCircle < 0.0) {
            finalColor = smoothColor(circle(u, v), uEdge, magenta, finalColor);
        } else {
            finalColor = smoothColor(circle(u, v), uEdge, yellow, finalColor);
        }
    }

    if(vPosition.y >= -1.5 && vPosition.y<4.0 && vPosition.x <18.15 && vPosition.x >-18.15) {
        gl_FragColor = vec4(finalColor + color, 1.0);
    }
    else {
        gl_FragColor = vec4(color, 1.0);
    }
}

</script>

<script type="x-shader/x-vertex" id="teapotFragmentShaderPlane">
	precision mediump float;

	uniform float uScale;
	uniform float uEdge;

	varying vec3 vPosition;
	varying vec3 vPosInCamera;
	varying vec3 vNormal;
	varying vec2 vUv;
	uniform float uDirX, uDirY, uDirZ, uShininess;
    #extension GL_OES_standard_derivatives : enable

   vec3 smoothColor(float f, float uEdge, vec3 firstColor, vec3 secondColor) {
       float grad = length(vec2(dFdx(f),dFdy(f)));
       float d = uEdge*grad;
       float edgeFactor = smoothstep(-d, d, f);
       return mix(firstColor, secondColor, edgeFactor);
   }

    float circle(float u, float v) {
        return u*u + v*v - 0.25*0.25;
    }

	void main() {

        vec3 nNormal = normalize(vNormal);

		vec3 ambColor = vec3(0.1,0.1,0.1);
      	vec3 diffColor = vec3(0.6,0.6,0.6);
		vec3 specColor = vec3(0.4,0.4,0.3);

		vec3 lightDir = normalize(vec3(uDirX,uDirY,uDirZ));
		float diffLightWeight = max(dot(nNormal,lightDir),0.0);
        vec3 eyeDir = normalize(-vPosInCamera);
        vec3 reflDir = -reflect(lightDir, nNormal);
        float specLightWeight = pow(max(dot(reflDir, eyeDir), 0.0), uShininess);
		vec3 lightWeight = ambColor + diffColor * diffLightWeight
			+ specColor * specLightWeight;
	    vec3 color = lightWeight;

    vec3 blue = vec3(0.0,0.0,0.9);
    vec3 yellow = vec3(1,1,0);
    vec3 magenta = vec3(1,0,1);
    vec3 cyan = vec3(0,1,1);

    float u = fract(vUv.x * uScale);
    float v = fract(vUv.y * uScale);
    float f = u*(u-0.5)*(u-1.0)*v*(v-0.5)*(v-1.0);
    vec3 finalColor = smoothColor(f, uEdge, magenta,blue);


    float downFunction = v + u - 1.0;
    float upFunction = -u + v;
    // right bottom blue outter circle
    if (v>0.5 && u>0.5) {
        finalColor = smoothColor(upFunction, uEdge, magenta, finalColor);
    } else if (v<0.5 && u <0.5) {
        finalColor = smoothColor(-upFunction, uEdge, magenta, finalColor);
    }
    else if (v>0.5 && u<0.5) {
        finalColor = smoothColor(downFunction, uEdge, blue, finalColor);
    }
     else {
        finalColor = smoothColor(-downFunction, uEdge, blue, finalColor);
    }

    //middle circle
    u = fract(vUv.x * uScale)-0.5;
    v = fract(vUv.y * uScale)-0.5;
    if (u>0.0 && v>u) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else if ((v<0.0 && u>0.0 && u>-v)) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else if ((v<0.0 && u<0.0 && v<u)) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else if ((u<0.0 && v>0.0 && -u>v)) {
        finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
    } else {
        finalColor = smoothColor(circle(u, v), uEdge, yellow, finalColor);
    }

    // bottom left circle
    u = fract(vUv.x * uScale)-0.25;
    v = fract(vUv.y * uScale)-0.25;

    float centerCircle = circle(u-0.25, v-0.25);
    if (v<u) {
        if (centerCircle < 0.0) {
            finalColor = smoothColor(circle(u, v), uEdge, blue, finalColor);
        } else {
            finalColor = smoothColor(circle(u, v), uEdge, cyan, finalColor);
        }
    } else {
        if (centerCircle < 0.0) {
            finalColor = smoothColor(circle(u, v), uEdge, magenta, finalColor);
        } else {
            finalColor = smoothColor(circle(u, v), uEdge, yellow, finalColor);
        }
    }

    gl_FragColor = vec4(finalColor, 1.0);

	}
</script>

<script type="text/javascript" id="mainCode">

    let control,
        container,
        renderer,
        scene,
        camera,
        mesh,
        start = Date.now(),
        fov = 30;

    window.addEventListener('load', function () {

        container = document.getElementById("container");

        scene = new THREE.Scene();

        camera = new THREE.PerspectiveCamera(
            fov,
            window.innerWidth / window.innerHeight,
            1,
            10000);
        camera.position.z = 100;
        camera.target = new THREE.Vector3(0, 0, 0);

        scene.add(camera);

        const teapotMaterial = new THREE.ShaderMaterial({
            uniforms: {
                uDirX: {type: 'f', value: 0.0},
                uDirY: {type: 'f', value: 0.0},
                uDirZ: {type: 'f', value: 0.0},
                uShininess: {type: 'f', value: 30.0},
                uScale: {type: 'f', value: 8.0},
                uEdge: {type: 'f', value: 0.0},
                redColor: {type: 'f', value: 0.4},
                greenColor: {type: 'f', value: 0.4},
                blueColor: {type: 'f', value: 0.3},
            },
            vertexShader: document.getElementById('teapotVertexShader').textContent,
            fragmentShader: document.getElementById('teapotFragmentShader').textContent
        });

        const teapotSize = 15;
        const segments = 20;
        let teapotGeometry = new THREE.TeapotGeometry(teapotSize, segments, true, true, true, true, true);
        let teapotMesh = new THREE.Mesh(teapotGeometry, teapotMaterial);
        scene.add(teapotMesh);

        const teapotMaterialPlane = new THREE.ShaderMaterial({
            uniforms: {
                uDirX: {type: 'f', value: 0.0},
                uDirY: {type: 'f', value: 0.0},
                uDirZ: {type: 'f', value: 0.0},
                uShininess: {type: 'f', value: 30.0},
                uScale: {type: 'f', value: 8.0},
                uEdge: {type: 'f', value: 0.0}
            },
            vertexShader: document.getElementById('teapotVertexShader').textContent,
            fragmentShader: document.getElementById('teapotFragmentShaderPlane').textContent
        });

        const planeGeometry = new THREE.PlaneGeometry(30, 30, 20, 20);
        mesh = new THREE.Mesh(planeGeometry, teapotMaterialPlane);
        mesh.position.x = 50;
        // scene.add(mesh);


        control = new function () {
            this.dirX = 0.5;
            this.dirY = 0.0;
            this.dirZ = 1.0;
            this.shin = 30.0;
            this.scale = 1.0;
            this.edge = 0.0;
        }
        const gui = new dat.GUI();
        gui.add(control, 'dirX', -1.0, 1.0, 0.5);
        gui.add(control, 'dirY', -1.0, 1.0, 0.0);
        gui.add(control, 'dirZ', -1.0, 2.0, 1.0);
        gui.add(control, 'scale', 1.0, 10.0);
        gui.add(control, 'edge', 0.0, 10.0);

        renderer = new THREE.WebGLRenderer({antialias: true});
        renderer.setSize(window.innerWidth, window.innerHeight);

        container.appendChild(renderer.domElement);
        const controls = new THREE.TrackballControls(camera, renderer.domElement);
        render();

        function render() {
            teapotMaterial.uniforms.uDirX.value = control.dirX;
            teapotMaterial.uniforms.uDirY.value = control.dirY;
            teapotMaterial.uniforms.uDirZ.value = control.dirZ;
            teapotMaterial.uniforms.uShininess.value = control.shin;
            teapotMaterial.uniforms.uScale.value = control.scale;
            teapotMaterial.uniforms.uEdge.value = control.edge;

            teapotMaterialPlane.uniforms.uDirX.value = control.dirX;
            teapotMaterialPlane.uniforms.uDirY.value = control.dirY;
            teapotMaterialPlane.uniforms.uDirZ.value = control.dirZ;
            teapotMaterialPlane.uniforms.uScale.value = control.scale;
            teapotMaterialPlane.uniforms.uEdge.value = control.edge;

            // render
            renderer.render(scene, camera);
            requestAnimationFrame(render);
            controls.update();
        }
    });

</script>

</html>

